"""
This is a quick-and-dirty assembler for T0 assembly. It accepts an input
T0 assembly file and outputs an assembled binary file. Alternatively, a
plaintext hex file can be generated by using the `--hex` option. 

Run the script with `python assembler.py <input_file> [-o <output_file>]`.

Expected Input Format:
  * There can be 0 or 1 instructions per line
  * Instructions cannot span multiple lines
  * Instruction tokens should be delimited with 1 ore more whitespaces
  * Whitespaces before and after the instruction are ignored
  * Comments begin with the `#` symbol

Instruction Sanitizing Method:
  1. Remove excessive whitespaces
  2. Remove comments and line breaks
  3. Remove leading/trailing whitespaces
"""

import argparse, os, re

# Symbol Dictionaries
paramSymbols = {
    "t_up": "0",
    "x_t_on": "1",
    "y_t_on": "2",
    "z_t_on": "3"
}

posSymbols = {
    "x": "0",
    "y": "1",
    "z": "2"
}

# Parse command line arguments
parser = argparse.ArgumentParser(
    description = "This program assembles T0 assembly into machine code."
)

parser.add_argument(
    "file",
    help="The input assembly file"
)

parser.add_argument(
    "-o",
    metavar="<file>",
    default="output", 
    help="Write the output to <file>"
)

parser.add_argument(
    "--hex",
    action="store_true",
    help="Write plaintext hex file"
)

args = parser.parse_args()

# Open files
inputFile = open(args.file, "r")
outputFile = open(args.o, "wb")

# Parse input file
lines = inputFile.readlines()
error = False
for i in range(len(lines)):
    # Sanitize the line
    line = lines[i]
    line = re.sub(r"\s{2,}", " ", line) # Remove excessive white-spaces
    line = re.sub(r"#.*|\n|\r", "", line) # Remove commends and line breaks
    line = re.sub(r"^\s|\s$", "", line) # Remove leading/trailing white-spaces

    if(line):
        # Tokenize the line
        tokens = line.split(" ")

        # Parse the tokens
        if(tokens[0] == "update"):
            if(len(tokens) == 1):
                lineHex = "00"
            else:
                error = True
        elif(tokens[0] == "setpos"):
            if( (len(tokens) == 3) and (tokens[1] in posSymbols) ):
                try:
                    data = "5" + posSymbols[tokens[1]]
                    payload = f"{(int(tokens[2]) & 0xffffffff):0{8}x}"
                    lineHex = data + payload
                except:
                    error = True
            else:
                error = True
        elif(tokens[0] == "setparam"):
            if( (len(tokens) == 3) and (tokens[1] in paramSymbols) ):
                try:
                    data = "6" + paramSymbols[tokens[1]]
                    payload = f"{(int(tokens[2]) & 0xffffffff):0{8}x}"
                    lineHex = data + payload
                except:
                    error = True
            else:
                error = True
        else:
            error = True

        # Handle errors, else output hex-encoded line to output file
        if(error):
            print(f"Syntax error on line {i+1}\n --> {line}")
            break
        else:
            if(args.hex):
                # Break up hex data into 2-character bytes (plaintext)
                for j in range(0, len(lineHex), 2):
                    outputFile.write((lineHex[j:j+2] + " ").encode())
                outputFile.write("\n".encode())
            else:
                # Write binary data to output file
                numBytes = int(len(lineHex) / 2)
                lineInt = int(lineHex, 16)
                outputFile.write(lineInt.to_bytes(length=numBytes))


# Close files
inputFile.close()
outputFile.close()

# Remove output file if an error occurred
if(error):
    os.remove(args.o)
